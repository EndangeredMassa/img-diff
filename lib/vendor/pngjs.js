// Generated by CoffeeScript 2.0.0-beta7
void function () {
  var fs, PNG, zlib, zpipe;
  fs = require('fs');
  zlib = require('zlib');
  zpipe = require('zpipe');
  module.exports = PNG = function () {
    PNG.decode = function (path, fn) {
      return fs.readFile(path, function (err, file) {
        var png;
        png = new PNG(file);
        return png.decode(function (pixels) {
          return fn(pixels);
        });
      });
    };
    PNG.load = function (path) {
      var file;
      file = fs.readFileSync(path);
      return new PNG(file);
    };
    function PNG(param$) {
      var chunkSize, colors, i, index, key, section, short, text;
      this.data = param$;
      this.pos = 8;
      this.palette = [];
      this.imgData = [];
      this.transparency = {};
      this.text = {};
      while (true) {
        chunkSize = this.readUInt32();
        section = function (accum$) {
          var i, i$;
          for (i$ = 0; i$ < 4; ++i$) {
            i = i$;
            accum$.push(String.fromCharCode(this.data[this.pos++]));
          }
          return accum$;
        }.call(this, []).join('');
        switch (section) {
        case 'IHDR':
          this.width = this.readUInt32();
          this.height = this.readUInt32();
          this.bits = this.data[this.pos++];
          this.colorType = this.data[this.pos++];
          this.compressionMethod = this.data[this.pos++];
          this.filterMethod = this.data[this.pos++];
          this.interlaceMethod = this.data[this.pos++];
          break;
        case 'PLTE':
          this.palette = this.read(chunkSize);
          break;
        case 'IDAT':
          for (var cache$ = function () {
                var accum$;
                accum$ = [];
                for (var i$ = 0; 0 <= chunkSize ? i$ < chunkSize : i$ > chunkSize; 0 <= chunkSize ? ++i$ : --i$)
                  accum$.push(i$);
                return accum$;
              }.apply(this, arguments), i$ = 0, length$ = cache$.length; i$ < length$; ++i$) {
            i = cache$[i$];
            this.imgData.push(this.data[this.pos++]);
          }
          break;
        case 'tRNS':
          this.transparency = {};
          switch (this.colorType) {
          case 3:
            this.transparency.indexed = this.read(chunkSize);
            short = 255 - this.transparency.indexed.length;
            if (short > 0)
              for (var cache$1 = function () {
                    var accum$;
                    accum$ = [];
                    for (var i$1 = 0; 0 <= short ? i$1 < short : i$1 > short; 0 <= short ? ++i$1 : --i$1)
                      accum$.push(i$1);
                    return accum$;
                  }.apply(this, arguments), i$1 = 0, length$1 = cache$1.length; i$1 < length$1; ++i$1) {
                i = cache$1[i$1];
                this.transparency.indexed.push(255);
              }
            break;
          case 0:
            this.transparency.grayscale = this.read(chunkSize)[0];
            break;
          case 2:
            this.transparency.rgb = this.read(chunkSize);
          }
          break;
        case 'tEXt':
          text = this.read(chunkSize);
          index = text.indexOf(0);
          key = String.fromCharCode.apply(String, [].slice.call(text.slice(0, index)).concat());
          this.text[key] = String.fromCharCode.apply(String, [].slice.call(text.slice(index + 1)).concat());
          break;
        case 'IEND':
          this.colors = function () {
            switch (this.colorType) {
            case 0:
            case 3:
            case 4:
              return 1;
            case 2:
            case 6:
              return 3;
            }
          }.call(this);
          this.hasAlphaChannel = this.colorType === 4 || this.colorType === 6;
          colors = this.colors + (this.hasAlphaChannel ? 1 : 0);
          this.pixelBitlength = this.bits * colors;
          this.colorSpace = function () {
            switch (this.colors) {
            case 1:
              return 'DeviceGray';
            case 3:
              return 'DeviceRGB';
            }
          }.call(this);
          this.imgData = new Buffer(this.imgData);
          return;
          break;
        default:
          this.pos += chunkSize;
        }
        this.pos += 4;
        if (this.pos > this.data.length)
          throw new Error('Incomplete or corrupt PNG file');
      }
    }
    PNG.prototype.read = function (bytes) {
      return function (accum$) {
        var i;
        for (var cache$ = function () {
              var accum$1;
              accum$1 = [];
              for (var i$ = 0; 0 <= bytes ? i$ < bytes : i$ > bytes; 0 <= bytes ? ++i$ : --i$)
                accum$1.push(i$);
              return accum$1;
            }.apply(this, arguments), i$ = 0, length$ = cache$.length; i$ < length$; ++i$) {
          i = cache$[i$];
          accum$.push(this.data[this.pos++]);
        }
        return accum$;
      }.call(this, []);
    };
    PNG.prototype.readUInt32 = function () {
      var b1, b2, b3, b4;
      b1 = this.data[this.pos++] << 24;
      b2 = this.data[this.pos++] << 16;
      b3 = this.data[this.pos++] << 8;
      b4 = this.data[this.pos++];
      return b1 | b2 | b3 | b4;
    };
    PNG.prototype.readUInt16 = function () {
      var b1, b2;
      b1 = this.data[this.pos++] << 8;
      b2 = this.data[this.pos++];
      return b1 | b2;
    };
    PNG.prototype.decodePixels = function (fn) {
      return zlib.inflate(this.imgData, function (this$) {
        return function (err, data) {
          var e, pixels;
          if (null != err)
            fn(err);
          try {
            pixels = this$._decodePixels(data);
          } catch (e$) {
            e = e$;
            err = e;
          }
          return fn(null, pixels);
        };
      }(this));
    };
    PNG.prototype.decodePixelsSync = function () {
      var buffer, data;
      data = zpipe.inflate(this.imgData.toString('binary'));
      buffer = new Buffer(data, 'binary');
      return this._decodePixels(buffer);
    };
    PNG.prototype._decodePixels = function (data) {
      var byte, c, col, i, left, length, p, pa, paeth, pb, pc, pixelBytes, pixels, pos, row, scanlineLength, upper, upperLeft;
      pixelBytes = this.pixelBitlength / 8;
      scanlineLength = pixelBytes * this.width;
      pixels = new Buffer(scanlineLength * this.height);
      length = data.length;
      row = 0;
      pos = 0;
      c = 0;
      while (pos < length) {
        switch (data[pos++]) {
        case 0:
          for (var cache$ = function () {
                var accum$;
                accum$ = [];
                for (var i$ = 0; 0 <= scanlineLength ? i$ < scanlineLength : i$ > scanlineLength; 0 <= scanlineLength ? ++i$ : --i$)
                  accum$.push(i$);
                return accum$;
              }.apply(this, arguments), i$ = 0, length$ = cache$.length; i$ < length$; ++i$) {
            i = cache$[i$];
            pixels[c++] = data[pos++];
          }
          break;
        case 1:
          for (var cache$1 = function () {
                var accum$;
                accum$ = [];
                for (var i$1 = 0; 0 <= scanlineLength ? i$1 < scanlineLength : i$1 > scanlineLength; 0 <= scanlineLength ? ++i$1 : --i$1)
                  accum$.push(i$1);
                return accum$;
              }.apply(this, arguments), i$1 = 0, length$1 = cache$1.length; i$1 < length$1; ++i$1) {
            i = cache$1[i$1];
            byte = data[pos++];
            left = i < pixelBytes ? 0 : pixels[c - pixelBytes];
            pixels[c++] = (byte + left) % 256;
          }
          break;
        case 2:
          for (var cache$2 = function () {
                var accum$;
                accum$ = [];
                for (var i$2 = 0; 0 <= scanlineLength ? i$2 < scanlineLength : i$2 > scanlineLength; 0 <= scanlineLength ? ++i$2 : --i$2)
                  accum$.push(i$2);
                return accum$;
              }.apply(this, arguments), i$2 = 0, length$2 = cache$2.length; i$2 < length$2; ++i$2) {
            i = cache$2[i$2];
            byte = data[pos++];
            col = (i - i % pixelBytes) / pixelBytes;
            upper = row && pixels[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];
            pixels[c++] = (upper + byte) % 256;
          }
          break;
        case 3:
          for (var cache$3 = function () {
                var accum$;
                accum$ = [];
                for (var i$3 = 0; 0 <= scanlineLength ? i$3 < scanlineLength : i$3 > scanlineLength; 0 <= scanlineLength ? ++i$3 : --i$3)
                  accum$.push(i$3);
                return accum$;
              }.apply(this, arguments), i$3 = 0, length$3 = cache$3.length; i$3 < length$3; ++i$3) {
            i = cache$3[i$3];
            byte = data[pos++];
            col = (i - i % pixelBytes) / pixelBytes;
            left = i < pixelBytes ? 0 : pixels[c - pixelBytes];
            upper = row && pixels[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];
            pixels[c++] = (byte + Math.floor((left + upper) / 2)) % 256;
          }
          break;
        case 4:
          for (var cache$4 = function () {
                var accum$;
                accum$ = [];
                for (var i$4 = 0; 0 <= scanlineLength ? i$4 < scanlineLength : i$4 > scanlineLength; 0 <= scanlineLength ? ++i$4 : --i$4)
                  accum$.push(i$4);
                return accum$;
              }.apply(this, arguments), i$4 = 0, length$4 = cache$4.length; i$4 < length$4; ++i$4) {
            i = cache$4[i$4];
            byte = data[pos++];
            col = (i - i % pixelBytes) / pixelBytes;
            left = i < pixelBytes ? 0 : pixels[c - pixelBytes];
            if (row === 0) {
              upper = upperLeft = 0;
            } else {
              upper = pixels[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];
              upperLeft = col && pixels[(row - 1) * scanlineLength + (col - 1) * pixelBytes + i % pixelBytes];
            }
            p = left + upper - upperLeft;
            pa = Math.abs(p - left);
            pb = Math.abs(p - upper);
            pc = Math.abs(p - upperLeft);
            if (pa <= pb && pa <= pc) {
              paeth = left;
            } else if (pb <= pc) {
              paeth = upper;
            } else {
              paeth = upperLeft;
            }
            pixels[c++] = (byte + paeth) % 256;
          }
          break;
        default:
          throw new Error('Invalid filter algorithm: ' + data[pos - 1]);
        }
        row++;
      }
      return pixels;
    };
    PNG.prototype.decodePalette = function () {
      var c, cache$1, i, length, palette, pos, ret, transparency;
      palette = this.palette;
      transparency = this.transparency.indexed || [];
      ret = new Buffer(transparency.length + palette.length);
      pos = 0;
      length = palette.length;
      c = 0;
      for (var cache$ = function () {
            var accum$;
            accum$ = [];
            for (var i$ = 0; 0 <= palette.length ? i$ < palette.length : i$ > palette.length; 0 <= palette.length ? ++i$ : --i$)
              accum$.push(i$);
            return accum$;
          }.apply(this, arguments), i$ = 0, length$ = cache$.length; i$ < length$; ++i$) {
        i = cache$[i$];
        ret[pos++] = palette[i];
        ret[pos++] = palette[i + 1];
        ret[pos++] = palette[i + 2];
        ret[pos++] = (cache$1 = transparency[c++], null != cache$1 ? cache$1 : 255);
      }
      return ret;
    };
    PNG.prototype.copyToImageData = function (imageData, pixels) {
      var alpha, colors, data, i, input, j, k, length, palette, v;
      colors = this.colors;
      palette = null;
      alpha = this.hasAlphaChannel;
      if (this.palette.length) {
        palette = null != this._decodedPalette ? this._decodedPalette : this._decodedPalette = this.decodePalette();
        colors = 4;
        alpha = true;
      }
      data = (null != imageData ? imageData.data : void 0) || imageData;
      length = data.length;
      input = palette || pixels;
      i = j = 0;
      if (colors === 1) {
        while (i < length) {
          k = palette ? pixels[i / 4] * 4 : j;
          v = input[k++];
          data[i++] = v;
          data[i++] = v;
          data[i++] = v;
          data[i++] = alpha ? input[k++] : 255;
          j = k;
        }
      } else {
        while (i < length) {
          k = palette ? pixels[i / 4] * 4 : j;
          data[i++] = input[k++];
          data[i++] = input[k++];
          data[i++] = input[k++];
          data[i++] = alpha ? input[k++] : 255;
          j = k;
        }
      }
    };
    PNG.prototype.decode = function (fn) {
      var ret;
      ret = new Buffer(this.width * this.height * 4);
      return this.decodePixels(function (this$) {
        return function (err, pixels) {
          if (null != err)
            return fn(err);
          this$.copyToImageData(ret, pixels);
          return fn(null, ret);
        };
      }(this));
    };
    PNG.prototype.decodeSync = function () {
      var pixels, ret;
      ret = new Buffer(this.width * this.height * 4);
      pixels = this.decodePixelsSync();
      this.copyToImageData(ret, pixels);
      return ret;
    };
    return PNG;
  }();
}.call(this);
